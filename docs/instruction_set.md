# 命令セットの網羅性

CPUは、自身が理解できる命令の集合（命令セット）に基づいて動作します。エミュレータが安定して動作するためには、この命令セットを正確かつ完全に実装することが不可欠です。

## 「未知の命令」によるパニック

開発の過程で、`Unkown instruction found for: 0x0` というエラーでプログラムがパニックしました。これは、プログラムカウンタが指すメモリ上の命令コード `0x00` に対応する処理が、我々のエミュレータに実装されていなかったために発生しました。

ゲームボーイのCPUにおいて、`0x00`は`NOP`（No Operation）という「何もしない」ことを指示する命令です。一見すると重要でないように思えるかもしれませんが、プログラムのタイミング調整や、コードのパディング（埋め草）など、重要な役割を担っています。

## 学び

エミュレータは、対象のCPUが持つ**すべての**命令コードに対して、何らかの処理を定義しなければなりません。もし一つでも未定義の命令があれば、その命令を含むプログラムを実行した際に、今回のようにクラッシュしてしまいます。

したがって、CPUをエミュレートする際は、たとえそれが`NOP`のような単純な命令であっても、公式の仕様書などに基づいて、すべての命令を網羅的に実装することが安定動作の鍵となります。

# アドレス空間と配列サイズ

開発中に `index out of bounds: the len is 65535 but the index is 65535` というパニックが発生しました。これは、確保したメモリ（配列）の範囲外にアクセスしようとしたことによる、メモリ安全性の高い言語ならではの重要なエラーです。

## なぜ `0xFFFF` ではなく `0x10000` なのか

このエラーの原因は、`0xFFFF`（10進数で65535）というアドレスにアクセスしようとした際、メモリを表す配列の長さが `0xFFFF`（65535要素）しか確保されていなかったためです。

- 配列のインデックスは `0` から始まるため、長さが `65535` の配列の有効なインデックスは `0` から `65534` までです。インデックス `65535` は範囲外となります。

ゲームボーイのCPUは16ビットのアドレスバスを持ち、`2^16` すなわち `65,536` 個のユニークなメモリアドレス（`0x0000` から `0xFFFF`）を扱えます。

ここで重要なのは「アドレスの数」です。たとえば `0` から `10` までの整数は `11` 個あるように、`0x0000` から `0xFFFF` までのアドレスも `0xFFFF - 0x0000 + 1 = 0x10000`（65,536個）となります。

## 学び

`0x0000` から `0xFFFF` までのアドレス範囲を完全にカバーするメモリアレイを作成するには、そのサイズ（要素数）は `0x10000` でなければなりません。

- **アドレス範囲**: `0x0000` ~ `0xFFFF`
- **必要な要素数**: `0x10000` (65,536)
- **配列の有効インデックス**: `0` ~ `65535` (`0xFFFF`)

このように、0から始まる範囲を扱う場合は「最大値に1を加えた数」が必要な配列サイズになる、という点はプログラミングの基本かつ重要な概念です。
