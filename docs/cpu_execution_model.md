# CPUの実行モデルと初期化

これまでの作業で、Rustのコードの構文エラーは解消されました。しかし、`cargo run`を実行しても "Emulator is starting!" と表示されるだけで、エミュレータの心臓部であるCPUは全く動作していませんでした。その理由は、CPUの「定義」はされていても、「インスタンス化」と「実行」が行われていなかったためです。

## 1. 「定義」と「インスタンス化」

`src/CPU.rs`に`struct CPU { ... }`と記述することは、あくまで「CPUとはこういうものである」という設計図を定義したに過ぎません。この設計図をもとに、実際に動作するCPUの「実体（インスタンス）」をメモリ上に作成する必要があります。

```rust
// src/main.rs (修正前)

fn main() {
    println!("Emulator is starting!");
    // CPUのインスタンスが作成されていない！
}
```

この問題を解決するには、`CPU`構造体のインスタンスを生成する処理が必要です。一般的に、Rustでは`new()`という関連関数（コンストラクタのようなもの）を用意します。

```rust
// src/main.rs (修正案)

fn main() {
    println!("Emulator is starting!");

    // CPUのインスタンスを作成する
    let mut cpu = cpu::CPU::new(); 
}
```

## 2. フェッチ・デコード・実行サイクル (Fetch-Decode-Execute Cycle)

CPUのインスタンスを作成しただけでは、まだ動きません。CPUは、「命令の取得（フェッチ）」「命令の解読（デコード）」「命令の実行（エグゼキュート）」という一連の処理を、クロック信号に合わせて無限に繰り返すことで動作します。これを**フェッチ・デコード・実行サイクル**と呼びます。

私たちのコードでは、このサイクル1回分に相当する処理が`step()`メソッドとして実装されています。

```rust
// src/CPU.rs

fn step(&mut self) {
    // 1. 命令をメモリからフェッチ
    let mut instruction_byte = self.bus.read_byte(self.pc);
    // ...

    // 2. 命令をデコード & 3. 実行
    let next_pc = if let Some(instruction) = Instruction::from_byte(instruction_byte, prefixed) {
      self.execute(instruction)
    } else {
      // ...
    };

    self.pc = next_pc;
}
```

エミュレータを動かすには、この`step()`メソッドを`main`関数内でループさせて、無限に呼び出し続ける必要があります。

```rust
// src/main.rs (修正案)

fn main() {
    println!("Emulator is starting!");
    let mut cpu = cpu::CPU::new();

    // 無限ループでCPUを動かし続ける
    loop {
        cpu.step();
    }
}
```

## 3. CPUの状態と初期化

CPUは、プログラムカウンタ（`pc`）、レジスタ、フラグなど、多くの内部「状態」を持っています。エミュレータを起動する際、これらの状態は特定の値（例えば、ゲームボーイの起動ROMが始まるアドレス）に初期化されている必要があります。

`CPU::new()`関数は、この初期化の役割を担います。ここで各レジスタやプログラムカウンタに初期値を設定することで、CPUは常に決まった状態から動作を開始できます。

---

**まとめ:** CPUを動かすには、単に構文的に正しいコードを書くだけでなく、
1.  `main`関数でCPUの**インスタンスを生成**し、
2.  そのインスタンスの`step()`メソッドを**ループで呼び出し続ける**ことで、
3.  **フェッチ・デコード・実行サイクル**を再現する
という、CPUの基本的な動作モデルをコードで表現する必要がある、という点が重要な学びとなります。
