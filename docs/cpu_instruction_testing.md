# CPU命令の単体テスト手法

エミュレータ開発において、CPUが各命令を正しく実行できるかを確認するテストは不可欠です。ここでは、アセンブリ言語を直接書く代わりに、機械語のバイト列（オペコード）を直接メモリにセットアップしてCPUの動作を検証する、効果的で一般的な単体テストの手法について解説します。

## 基本的な考え方

テストしたいCPU命令（例: `LD BC, 0x1234`）がある場合、その命令に対応するバイト列を特定します。ゲームボーイのCPU（LR35902）では、この命令は以下のバイト列に対応します。

- `0x01`: `LD BC, d16` という命令のオペコード
- `0x34`: 16ビットの即値 `d16` の下位バイト (Little Endian)
- `0x12`: 16ビットの即値 `d16` の上位バイト (Little Endian)

このバイト列 `[0x01, 0x34, 0x12]` をプログラムと見なし、エミュレータのメモリに書き込み、CPUに実行させて結果を検証します。

## テストの実装手順

1.  **テスト環境の準備**: `CPU`の新しいインスタンスを作成します。
2.  **プログラムの作成**: テストしたい命令に対応するバイト列を `Vec<u8>` などで定義します。
3.  **メモリへの書き込み**: 作成したプログラム（バイト列）を、エミュレータのメモリバス（`bus`）の先頭アドレス（`0x0000`など）から順に書き込みます。
4.  **CPUの実行**: `cpu.step()` メソッドを呼び出して、1命令を実行させます。
5.  **結果の検証**: `assert_eq!` などを使って、命令実行後のCPUの状態が期待通りかを確認します。チェックすべき項目は主に以下の通りです。
    -   **プログラムカウンタ (`pc`)**: 命令の長さ分だけ進んでいるか？
    -   **レジスタ**: 値が正しくロードされたか、あるいは計算結果が正しいか？
    -   **フラグレジスタ**: ゼロフラグやキャリーフラグなどが正しくセット／リセットされたか？

## 具体的なテストコード例

`LD BC, 0x0305` 命令をテストする際の具体的なコードは以下のようになります。

```rust
// tests/cpu_test.rs

use emulator::cpu::CPU;

#[test]
fn ld_bc_d16() {
    // 1. テスト環境の準備
    let mut cpu = CPU::new();

    // 2. プログラムの作成 (LD BC, 0x0305)
    let program = vec![0x01, 0x05, 0x03];

    // 3. メモリへの書き込み
    for (i, &byte) in program.iter().enumerate() {
        cpu.bus.write_byte(i as u16, byte);
    }

    // 4. CPUの実行
    cpu.step();

    // 5. 結果の検証
    // プログラムカウンタは3バイト進むはず
    assert_eq!(cpu.pc, 0x03);
    // BCレジスタに 0x0305 がロードされているはず
    assert_eq!(cpu.registers.get_bc(), 0x0305);
}
```

## この手法の利点

- **正確性**: アセンブラを介さず、CPUが直接解釈するバイト列を扱うため、命令の挙動を正確にテストできます。
- **独立性**: 各命令を個別にテストできるため、問題の切り分けが容易になります。
- **シンプルさ**: テストのために完全なアセンブラを実装する必要がありません。
